---
id: concurrent-mode-adoption
title: Использование конкурентного режима (экспериментально)
permalink: docs/concurrent-mode-adoption.html
prev: concurrent-mode-patterns.html
next: concurrent-mode-reference.html
---

<style>
.scary > blockquote {
  background-color: rgba(237, 51, 21, 0.2);
  border-left-color: #ed3315;
}
</style>

<div class="scary">

>Внимание:
>
>Эта страница посвящена **экспериментальным возможностям, которых еще нет в стабильной версии**. Информация предназначена для ранних пользователей и просто интересующихся.
>
>Большая часть информации на данной странице уже не актуальна и оставлена для истории. **Актуальная информация приведена в посте блога [React 18 Alpha announcement](/blog/2021/06/08/the-plan-for-react-18.html).**
>
>Перед выходом React 18 информация на этой странице будет обновлена.

</div>

- [Установка](#installation)
  - [Для кого предназначены экспериментальные релизы?](#who-is-this-experimental-release-for)
  - [Включение конкурентного режима](#enabling-concurrent-mode)
- [К чему готовиться?](#what-to-expect)
  - [Промежуточный этап: блокирующий режим](#migration-step-blocking-mode)
  - [Зачем столько режимов?](#why-so-many-modes)
  - [Сравнение возможностей](#feature-comparison)

## Установка {#installation}

Конкурентный режим доступен только в [экспериментальных сборках](/blog/2019/10/22/react-release-channels.html#experimental-channel) React. Чтобы установить их, выполните:

```
npm install react@experimental react-dom@experimental
```

**Для экспериментальных сборок нет гарантий семантического версионирования**

В любом релизе с версией `@experimental` функции API могут быть добавлены, изменены или удалены.

**Экспериментальные релизы будут часто содержать критические изменения.**

Вы можете пробовать такие сборки в личных проектах или в ветках, однако мы не рекомендуем использовать их в продакшене. В Facebook мы *используем* их в продакшене, поскольку можем исправлять ошибки, если что-то сломается. Мы вас предупредили.

### Для кого предназначен этот экспериментальный релиз? {#who-is-this-experimental-release-for}

Этот релиз предназначен в первую очередь для ранних пользователей, авторов библиотек и интересующихся.

Мы используем экспериментальный код в продакшене (это работает для нас), несмотря на то, что в нем есть некоторое количество ошибок, недоделанные возможности и пробелы в документации. Нам бы хотелось выявить ошибки в конкурентном режиме, чтобы лучше подготовить его к официальному стабильному релизу в будущем.

### Включение конкурентного режима {#enabling-concurrent-mode}

Обычно, когда мы добавляем новые возможности в React, вы можете сразу же использовать их. Например, фрагменты, контекст и даже хуки были именно такими. Их можно использовать в новом коде не меняя уже существующий.

С конкурентным режимом другая история. В нём изменена сама суть работы React. В противном случае использование [новых возможностей](/docs/concurrent-mode-patterns.html) *было бы невозможно*. Именно поэтому они объединены в новый "режим", а не выпускаются по-отдельности.

Вы не можете использовать конкурентный режим для отдельных поддеревьев. Включать конкурентный режим нужно в том же месте, где ранее вы вызывали функцию `ReactDOM.render()`.

**Включение конкурентного режима для всего дерева `<App />`:**

```js
import ReactDOM from 'react-dom';

// Раньше вы использовали:
//
// ReactDOM.render(<App />, document.getElementById('root'));
//
// Теперь для перехода в конкурентный режим нужно написать:

ReactDOM.unstable_createRoot(
  document.getElementById('root')
).render(<App />);
```

>Примечание:
>
>Функции API конкурентного режима доступны только в экспериментальных сборках React.

В конкурентном режиме методы жизненного цикла, [ранее помеченные](/blog/2018/03/27/update-on-async-rendering.html) как "небезопасные", *становятся* действительно небезопасными и приводят к ошибкам гораздо чаще, чем в текущих релизах React. Мы не рекомендуем использовать конкурентный режим, пока ваше приложение не будет поддерживать [строгий режим](/docs/strict-mode.html).

## К чему готовиться? {#what-to-expect}

Если у вас достаточно большое приложение или в нём много сторонних зависимостей, не стоит надеяться на быстрый переход на конкурентный режим. **Например, в Facebook мы используем конкурентный режим только на новых сайтах и не планируем задействовать его на старых.** Это из-за того, что старые сайты в продакшен-коде используют небезопасные методы жизненного цикла, несовместимые библиотеки сторонних разработчиков и паттерны, которые плохо работают в конкурентном режиме.

По нашему опыту, код, который использует классические паттерны React и не полагается на решения для управления внешним состоянием, проще всего запустить в параллельном режиме. В ближайшее время мы опишем проблемы, которые смогли обнаружить, и способы их решения.

### Этап миграции: блокирующий режим {#migration-step-blocking-mode}

Для старых проектов путь перехода на конкурентный режим может оказаться достаточно длинным. Поэтому в экспериментальных сборках React мы предусмотрели новый "блокирующий режим". Вы можете попробовать его, заменив `createRoot` на `createBlockingRoot`. Блокирующий режим предоставляет *сокращённый набор* возможностей конкурентного режима. При этом он ближе к тому, как работает React в настоящее время, и может послужить в качестве промежуточного этапа.

Итого:

* **Старый режим:** `ReactDOM.render(<App />, rootNode)`. Это режим, в котором React работает в настоящее время. В обозримом будущем мы не планируем избавляться от старого режима, но он не будет поддерживать новые возможности.
* **Блокирующий режим:** `ReactDOM.createBlockingRoot(rootNode).render(<App />)`. В настоящее время экспериментальный. Он предназначен в качестве первого этапа миграции приложений, в которых предполагается использовать часть возможностей конкурентного режима.
* **Конкурентный режим:** `ReactDOM.createRoot(rootNode).render(<App />)`. В настоящее время экспериментальный. В будущем, после стабилизации, мы намерены сделать его основным режимом React. Данный режим задействует *все* новые возможности.

### Зачем столько режимов? {#why-so-many-modes}

Мы считаем, что лучше предложить [стратегию постепенной миграции](/docs/faq-versioning.html#commitment-to-stability), чем вносить огромные серьезные изменения или позволить React стагнировать.

На практике мы ожидаем, что большинство приложений, использующих в настоящее время старый режим, смогут перейти на конкурентный или, как минимум, на блокирующий. Такая фрагментация может создать некоторые проблемы для авторов библиотек, которые будут вынуждены какое-то время поддерживать все режимы. Однако нужно учитывать, что постепенный переход со старого режима помогает решать проблемы, влияющие на основные библиотеки в экосистеме React, например, [странное поведение Задержек при чтении DOM](https://github.com/facebook/react/issues/14536) и [нестабильность пакетного рендеринга](https://github.com/facebook/react/issues/15080). Есть некоторое количество багов, которые невозможно исправить без изменения семантики в старом режиме, но при этом они отсутствуют в блокирующем или конкурентном режимах.

Вы можете рассматривать блокирующий режим как "отказоустойчивую" версию конкурентного режима. **В конечном итоге, в долгосрочной перспективе, у нас будет возможность объединить оба режима и перестать рассматривать их как отдельные друг от друга.** В настоящее время режимы являются важной частью переходной стратегии. Они дают возможность каждому определять момент перехода на конкурентный режим и обновлять код в удобном для себя темпе.

### Сравнение возможностей {#feature-comparison}

<style>
  #feature-table table { border-collapse: collapse; }
  #feature-table th { padding-right: 30px; }
  #feature-table tr { border-bottom: 1px solid #eee; }
</style>

<div id="feature-table">

|   |Старый режим  |Блокирующий режим  |Конкурентный режим  |
|:---  |:---  |:---  |:---  |
|[Строковые рефы](/docs/refs-and-the-dom.html#legacy-api-string-refs)  |✅  |🚫**  |🚫**  |
|[Старый контекст](/docs/legacy-context.html) |✅  |🚫**  |🚫**  |
|[findDOMNode](/docs/strict-mode.html#warning-about-deprecated-finddomnode-usage)  |✅  |🚫**  |🚫**  |
|[Задержка](/docs/concurrent-mode-suspense.html#what-is-suspense-exactly) |✅  |✅  |✅  |
|[SuspenseList](/docs/concurrent-mode-patterns.html#suspenselist) |🚫  |✅  |✅  |
|Задержка в React на сервере + гидратация |🚫  |✅  |✅  |
|Последовательная гидратация  |🚫  |✅  |✅  |
|Выборочная гидратация  |🚫  |🚫  |✅  |
|Кооперативная многозадачность |🚫  |🚫  |✅  |
|Автоматическая группировка при множественном вызове setStates     |🚫* |✅  |✅  |
|[Приоритетный рендеринг](/docs/concurrent-mode-patterns.html#splitting-high-and-low-priority-state) |🚫  |🚫  |✅  |
|[Прерываемый предварительный рендеринг](/docs/concurrent-mode-intro.html#interruptible-rendering) |🚫  |🚫  |✅  |
|[useTransition](/docs/concurrent-mode-patterns.html#transitions)  |🚫  |🚫  |✅  |
|[useDeferredValue](/docs/concurrent-mode-patterns.html#deferring-a-value) |🚫  |🚫  |✅  |
|[Периодические задержки типа "Train"](/docs/concurrent-mode-patterns.html#suspense-reveal-train)  |🚫  |🚫  |✅  |

</div>

\*: Старый режим имеет автоматический пакетный рендеринг для обрабатываемых React событий, но он ограничен одним потоком браузера. Не React-события должны быть обработаны через `unstable_batchedUpdates`. В блокирующем и конкурентном режимах все вызовы `setState` группируются для пакетного рендеринга по-умолчанию.

\*\*: Предупреждения в режиме разработки.
